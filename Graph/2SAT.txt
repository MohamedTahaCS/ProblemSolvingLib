(a or b) ^ (!a or b) ^ (z or !c)

(a or b) equiv to:
!a -> b
!b -> a

// example problem with solution
The first input line has two integers n and m: the number of family members and toppings. The toppings are numbered 1,2,\dots,m.
After this, there are n lines describing the wishes. Each line has two wishes of the form "+ x" (topping x is good) or "- x" (topping x is bad).
3 5
+ 1 + 2
- 1 + 3
+ 4 - 2
Output:

- + + + -

int32_t main() {
    FAST
    int n , m;
    cin >> n >> m;
 
    vector<vector<int>> adj(N);
 
    for (int i = 0 ; i < n ; i++) {
        char ch ; int x;
        cin >> ch >> x;
        char ch2; int y;
        cin >> ch2 >> y;
 
        int node1 = (ch == '+') ? 2 * x : 2 * x + 1;
        int node2 = (ch2 == '+') ?  2 * y : 2 * y + 1;
 
        int negNode1 = (ch != '+') ? 2 * x : 2 * x + 1;
        int negNode2 = (ch2 != '+') ?  2 * y : 2 * y + 1;
        adj[negNode1].push_back(node2);
        adj[negNode2].push_back(node1);
 
    }
 
    SCC scc(adj, 2 * m + 2);
 
    bool f = true;
    for (int i = 1 ; i <= m ; i++) {
        if (scc.comp[i * 2] == scc.comp[i * 2 + 1]) f = false;
    }
 
    if (f) {
        bool ans[m + 1];
        for (int i = 1 ; i <= m ; i ++) {
 
            ans[i] = scc.comp[i * 2] > scc.comp[i * 2 + 1];
        }
        for (int i = 1 ; i <= m ; i++) {
            if (ans[i]) cout << "+";
            else cout << "-";
            cout <<" ";
        }
    } else cout <<"IMPOSSIBLE";
}

First we prove that the vertex  
x  cannot reach the vertex  
not x . Because we assigned  
true  it has to hold that the index of strongly connected component of  
x  is greater than the index of the component of  
not x . This means that  
not x  is located on the left of the component containing  
x , and the later vertex cannot reach the first.